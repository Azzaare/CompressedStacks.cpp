The Compressed\+Stacks.\+cpp module/library implements a time-\/space trade-\/off structure for stack\textquotesingle{}s algorithms.

\subsection*{Category of algorithms}

This compressed stack structure works correctly as a normal stack for any problems that read input from a file. However, the running time is optimal when the input would be read sequentially with a classical stack structure. For this reason, the only function implemented in the \hyperlink{class_problem}{Problem} template to solve it (to do a run) is the one presented below in a simplified version. 


\begin{DoxyCode}
\textcolor{keyword}{template} <\textcolor{keyword}{class} T, \textcolor{keyword}{class} D> \textcolor{keywordtype}{void} \hyperlink{class_problem}{Problem<T, D>::run}() \{
  initStack();
  \textcolor{keywordflow}{while} (notEndOfFile()) \{
    D data = readInput(line);
    \textcolor{keywordflow}{while} (notEmptystack() && popCondition(data)) \{
      elt = pop();
      popAction(elt);
    \}
    \textcolor{keywordflow}{if} (pushCondition(data)) \{
      pushAction(data);
      push(data);
    \}
  \}
\}
\end{DoxyCode}


\subsection*{Characterization of a problem}

In the followwing examples, implementations of the \hyperlink{class_problem}{Problem} interface are given.

\subsubsection*{General example \+: {\ttfamily \hyperlink{class_instance}{Instance}$<$T,D$>$}}


\begin{DoxyCode}
\textcolor{preprocessor}{#include <string>}
\textcolor{preprocessor}{#include <vector>}
\textcolor{preprocessor}{#include <memory>}

\textcolor{comment}{// T is the type of the context and D is the type of the input data.}
\textcolor{keyword}{class }\hyperlink{class_instance}{Instance}: \textcolor{keyword}{public} \hyperlink{class_problem}{Problem}<T,D>\{
\textcolor{keyword}{public}:
  \hyperlink{class_instance}{Instance}(std::string filePath) : \hyperlink{class_problem}{Problem}<T, D>(filePath) \{\}
\textcolor{keyword}{private}:
  \textcolor{comment}{// Functions to implement according to the problem and input}
  D readInput(std::vector<std::string> line)\{
    std::cout << \textcolor{stringliteral}{"Implement readInput for your instance"} << std::endl;
    \textcolor{keywordflow}{return} 0;
  \}
  std::shared\_ptr<T> initStack()\{
    std::cout << \textcolor{stringliteral}{"Implement initStack for your instance"} << std::endl;
    std::shared\_ptr<T> context(\textcolor{keyword}{nullptr});
    \textcolor{keywordflow}{return} context;
  \}
  \textcolor{keywordtype}{bool} popCondition(D data)\{
    std::cout << \textcolor{stringliteral}{"Implement mPopCondition for your instance"} << std::endl;
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \}
  \textcolor{keywordtype}{void} popAction(\hyperlink{class_data}{Data<T, D>} elt)\{
    std::cout << \textcolor{stringliteral}{"Implement mPopAction for your instance"} << std::endl;
  \}
  \textcolor{keywordtype}{bool} pushCondition(D data)\{
    std::cout << \textcolor{stringliteral}{"Implement mPushCondition for your instance"} << std::endl;
    \textcolor{keywordflow}{return} \textcolor{keyword}{true};
  \}
  \textcolor{keywordtype}{void} pushAction(\hyperlink{class_data}{Data<T, D>} elt)\{
    std::cout << \textcolor{stringliteral}{"Implement mPushAction for your instance"} << std::endl;
  \}
\};
\end{DoxyCode}


\subsubsection*{Example with {\ttfamily T = int} and {\ttfamily D = int} \+: {\ttfamily \hyperlink{class_instance}{Instance}$<$int,int$>$}}

The context is initialized at 0. The data (in cvs format) is read as a pair of string such that the first string is the data and the second is used to update the context. While the context is more than 0, the stack is poped and the context decreased by 1. If the data is more than 0 then it is pushed. 
\begin{DoxyCode}
\textcolor{keyword}{class }\hyperlink{class_instance}{Instance} : \textcolor{keyword}{public} \hyperlink{class_problem}{Problem}<int, int> \{
\textcolor{keyword}{public}:
  \hyperlink{class_instance}{Instance}(std::string filePath) : \hyperlink{class_problem}{Problem}<int, int>(filePath) \{\}

\textcolor{keyword}{private}:
  \textcolor{comment}{// Functions to run the stack}
  \textcolor{keywordtype}{int} readInput(std::vector<std::string> line) \{
    \textcolor{keywordtype}{int} value = std::stoi(line[0]);
    setContext(std::stoi(line[1]));
    \textcolor{keywordflow}{return} value;
  \}
  std::shared\_ptr<int> initStack() \{
    std::shared\_ptr<int> context(\textcolor{keyword}{new} \textcolor{keywordtype}{int}(0));
    \textcolor{keywordflow}{return} context;
  \}
  \textcolor{keywordtype}{bool} popCondition(\textcolor{keywordtype}{int} data) \{
    \textcolor{keywordflow}{if} ((getContext() > 0)) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \}
  \textcolor{keywordtype}{void} popAction(\hyperlink{class_data}{Data<int, int>} elt) \{
    std::cout << elt.toString() << \textcolor{stringliteral}{" <<<< Pop!"} << std::endl;
    setContext(getContext() - 1);
  \}
  \textcolor{keywordtype}{bool} pushCondition(\textcolor{keywordtype}{int} data) \{
    \textcolor{keywordflow}{if} (data > 0) \{
      \textcolor{keywordflow}{return} \textcolor{keyword}{true};
    \}
    \textcolor{keywordflow}{return} \textcolor{keyword}{false};
  \}
  \textcolor{keywordtype}{void} pushAction(\hyperlink{class_data}{Data<int, int>} elt) \{
    std::cout << \textcolor{stringliteral}{"Push >>>> "} << elt.toString() << std::endl;
  \}
\};
\end{DoxyCode}


\subsection*{How to run your problem}

Suppose the class \hyperlink{class_instance}{Instance} implement the interface Problem$<$\+T,\+D$>$ (as in some examples above). You can run an instance of your problem described in the input located at {\itshape filepath}. The last command just print an output in th console of your compressed stack after the run.


\begin{DoxyCode}
\hyperlink{class_instance}{Instance} stack(filePath);
stack.run();
stack.println();
\end{DoxyCode}
 